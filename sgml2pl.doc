\documentclass[11pt]{article}
\usepackage{pl}
\usepackage{html}

\onefile
\htmloutput{html}				% Output directory
\htmlmainfile{index}				% Main document file
\bodycolor{white}				% Page colour

\renewcommand{\runningtitle}{SWI-Prolog SGML/XML parser}

\newcommand{\anyml}{{\cal X}ML}
\newcommand{\elem}[1]{{\tt\string<#1\string>}}

\begin{document}

\title{SWI-Prolog SGML/XML parser}
\author{Jan Wielemaker \\
	SWI, \\
	University of Amsterdam \\
	The Netherlands \\
	E-mail: \email{jan@swi.psy.uva.nl}}

\maketitle

\begin{abstract}
Markup languages are an increasingly important method for
data-representation and exchange.  This article documents the package
{\em sgml2pl}, a foreign library for SWI-Prolog to parse SGML
and XML documents, returning information on both the document and the
document's DTD.  The parser is designed to be small, fast and flexible.
\end{abstract}

\vfill

\tableofcontents

\vfill
\vfill

\newpage


\section{Introduction}

Markup languages have recently regained popularity for two reasons.  One
is document exchange, which is largely based on HTML, an instance of
SGML and the other is for data-exchange between programs, which is often
based on XML, which can be considered simplified and rationalised
version of SGML.

James Clark's SP parser is a flexible SGML and XML parser. Unfortunately
it has some drawbacks. It is very big, not very fast, cannot work under
event-driven input and is generally hard to program beyond the scope of
the well designed generic interface. The generic interface however does
not provide access to the DTD, does not allow for flexible handling of
input or parsing the DTD independently of a document instance.

The parser described in this document is small (less than 50 Kbytes
executable on a Pentium), fast (between 2 and 5 times faster than
SP), provides access to the DTD and flexible input handling.

The document output is equal to the output produced by \jargon{xml2pl},
an SP interface to SWI-Prolog written by Anjo Anjewierden.


\section{Bluffers Guide}

This package allows you to parse SGML, XML and HTML data into a Prolog
data structure. The high-level interface defined in \pllib{sgml}
provides access at the file-level, while the low-level interface defined
in the foreign module works with Prolog streams.  Please use the source
of \file{sgml.pl} as a starting point for dealing with data from other
sources than files, such as SWI-Prolog resources, network-sockets,
character strings, etc.  In the first example below loads an HTML file.

\begin{code}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
<title>Demo</title>
</head>
<body>

<h1 align=center>This is a demo</h1>

<p>Paragraphs in HTML need not be closed.

<p>This is called `omitted-tag' handling.
</body>
</html>
\end{code}

\begin{code}
?- load_html_file('test.html', Term),
   pretty_print(Term).

[ element(html,
          [],
          [ element(head,
                    [],
                    [ element(title,
                              [],
                              [ 'Demo'
                              ])
                    ]),
            element(body,
                    [],
                    [ '\n',
                      element(h1,
                              [ align = center
                              ],
                              [ 'This is a demo'
                              ]),
                      '\n\n',
                      element(p,
                              [],
                              [ 'Paragraphs in HTML need not be closed.\n'
                              ]),
                      element(p,
                              [],
                              [ 'This is called `omitted-tag\' handling.'
                              ])
                    ])
          ])
].
\end{code}

The document is represented as a list, each element being an atom to
represent \const{CDATA} or a term \term{element}{Name, Attributes,
Content}. Entities (e.g.\ \verb$&lt$) are returned as part of
\const{CDATA}, unless they cannot be represented. See load_sgml_file/2
for details.


\subsection{`Goodies' Predicates}

These predicates are for basic usage of the library, converting entire
and self-contained files in one of the three supported \anyml{} dialects
into a structured term.  They are all expressed in load_structure/3.

\begin{description}
    \predicate{load_sgml_file}{2}{+File, -ListOfContent}
Same as \term{load_structure}{File, ListOfContent, [dialect(sgml)]}.
    \predicate{load_xml_file}{2}{+File, -ListOfContent}
Same as \term{load_structure}{File, ListOfContent, [dialect(xml)]}.
    \predicate{load_html_file}{2}{+File, -Content}
Load \arg{File} and parse as HTML.  Implemented as:

\begin{code}
load_html_file(File, Term) :-
	dtd(html, DTD),
	load_structure(File, Term,
		       [ dtd(DTD),
			 dialect(sgml)
		       ]).
\end{code}
\end{description}


\section{Predicate Reference}

\subsection{Loading Structured Documents}

SGML or XML files are loaded through the common predicate
load_structure/3. This is a predicate with many options. For simplicity
a number of commonly used shorthands are provided: load_sgml_file/2,
load_xml_file/2, and load_html_file/2.

\begin{description}
    \predicate{load_structure}{3}{+File, --ListOfContent, +Options}
Load the \anyml{} file \arg{File} and return the resulting structure
in \arg{ListOfContent}. \arg{Options} is a list of options controlling the
conversion process.

A proper \anyml{} document contains only a single toplevel element whose
name matches the document type.  Nevertheless, a list is returned for
consistency with the representation of element content. The
\arg{ListOfContent} consists of three types:

\begin{description}
    \termitem{\arg{Atom}}{}
Atoms are used to represent \const{CDATA}.  Note this is possible
in SWI-Prolog, as there is no length-limit on atoms and atom garbage
collection is provided.

    \termitem{element}{Name, ListAttributes, ListOfContent}
\arg{Name} is the name of the element. Using SGML, which is
case-insensitive, all element names are returned as lowercase atoms.

\arg{ListOfAttributes} is a list of \arg{Name}=\arg{Value} pairs for
attributes that appeared in the source. No information is returned on
other attributes, such as \const{fixed} or \const{default} attributes.
See dtd_property/2 for accessing the DTD for this information.
Attributes of type \const{CDATA} are returned literal. Attributes of
type \const{NUMBER} are returned as a Prolog integer.  Multi-valued
attributes (\const{NAMES}, etc.) are returned as a list of atoms.
For the type \const{NUMBERS}, a list of Prolog integers is returned
for any element of the list that can be converted into an integer.

\arg{ListOfContent} defines the content for the element.

    \termitem{entity}{Code}
If a character-entity (e.g. \verb$&#913;$) is encoutered that cannot
be represented in the Prolog character set, this term is returned,
representing the referred character code.

    \termitem{entity}{Name}
If an entity refers to a character-entity holding a single character,
but this character cannot be represented in the Prolog character set,
this term is returned. For example, the HTML input text
\verb$&Alpha; &lt &Beta;$ is returned as below. Please note that neither
in XML nor SGML entities are case-insensitive.  

\begin{code}
[ entity('Alpha'), ' < ', entity('Beta') ]
\end{code}

This is a special case of \term{entity}{Code}, intended to handle
special symbols by their name rather then character code.

    \termitem{sdata}{Text}
If an entity width declared content-type \const{SDATA} is encountered,
this term is returned holding the data in \arg{Text}.

    \termitem{ndata}{Text}
If an entity width declared content-type \const{NDATA} is encountered,
this term is returned holding the data in \arg{Text}.

    \termitem{pi}{Text}
If a processing instruction is encoutered (\verb$<?...?>$), \arg{Text}
holds the text of the processing instruction.  Please note that the
\verb$<?xml ...?>$ instruction is handled internally.
\end{description}

The \arg{Options} list controls the conversion process.  Currently
defined options are:

\begin{description}
    \termitem{dtd}{?DTD}
Reference to a DTT object.  If specified, the \verb$<!DOCTYPE ...>$
declaration is ignored and the document is parsed and validated against
the provided DTD.  If provided as a variable, the implicitly created
DTD is returned.  See \secref{implicitdtd}.

    \termitem{dialect}{+Dialect}
Specify the parsing dialect.  Supported are \const{sgml} (default),
\const{xml} and \const{xmlns}. See \secref{xml} for details on the
differences.

    \termitem{space}{+SpaceMode}
Sets the `space-handling-mode' for the initial environment.  This mode
is inherited by the other environments and subject to the XML reserved
tag \elem{xml:space}.  See \secref{space}.

    \termitem{file}{+Name}
Sets the name of the file on which errors are reported. Sets the
linenumber to 1.

    \termitem{line}{+Line}
Sets the starting line-number for reporting errors.

    \termitem{max_errors}{+Max}
Sets the maximum number of errors.  If this number is reached, an
exception of the format below is raised.  The default is 50.

\begin{quote}
\term{error}{\term{limit_exceeded}{max_errors, Max}, _}
\end{quote}
\end{description}
\end{description}


\subsection{Handling white-space}		\label{sec:space}

SGPL2PL has four modes for handling white-space.  The initial mode can
be switched using the \term{space}{SpaceMode} option to load_structure/3
and set_sgml_parser/2.  In XML mode, the mode is further controlled by
the \elem{xml:space} attribute, which may be specified both in the DTD
as in the document.  The defined modes are:

\begin{description}
    \termitem{space}{sgml}
In SGML, newlines at the start and end of an element are removed.%
	\footnote{In addition, newlines at the end of lines containing
		  only markup should be deleted.  This is not yet
		  implemented.}
This is the default mode for the SGML dialect.
    \termitem{space}{preserve}
White space is passed literally to the application.  This is the default
mode. This mode leaves all white space handling to the application. This
is the default mode for the XML dialect.
    \termitem{space}{default}
In addition to \const{sgml} space-mode, all consequtive white-space is
reduced to a single space-character. This mode canonises all white
space.
    \termitem{space}{remove}
In addition to \const{default}, all leading and trailing white-space is
removed from \const{CDATA} objects. If, as a result, if the
\const{CDATA} becomes empty, nothing is passed to the application. This
mode is especially handy for processing `data-oriented' documents, such
as RDF. It is not suitable for normal text documents. Consider the HTML
statement below. When processed in this mode, the spaces between the
three modified words are lost. This mode is, unlike the two others, not
part of the XML standard.

\begin{code}
Consider adjecent <b>bold</b> <ul>and</ul> <it>italic</it> words.
\end{code}
\end{description}


\subsection{XML documents}			\label{sec:xml}

The parser can operate in two modes: \const{sgml} mode and \const{xml}
mode, as defined by the \term{dialect}{Dialect} option. Regardless of
this option, if the first line of the document reads as below, the
parser is switched automatically into XML mode.

\begin{code}
<?xml ... ?>
\end{code}

Currently switching to XML mode implies:

\begin{itemlist}
    \item [XML empty elements]
The construct \verb$<element [attribute...] />$ is recognised as an
empty element.
    \item [Predefined entities]
The following entitities are predefined:
\const{lt} (\verb$<$),
\const{gt} (\verb$>$),
\const{amp} (\verb$&$),
\const{apos} (\verb$'$) and
\const{quot} (\verb$"$).
    \item [Case sensitivity]
In XML mode, names are treated case-sensitive, except for the DTD
reserved names (i.e. \const{ELEMENT}, etc.).
    \item [Character classes]
In XML mode, underscores (\verb$_$) and colon (\verb$:$) are allowed in
names.
    \item [White-space handling]
White space mode is set to \const{preserve}. In addition to setting
white-space handling at the toplevel the XML reserved attribute
\elem{xml:space} is honoured. It may appear both in the document as the
DTD. The \const{remove} extension is honoured as \elem{xml:space} value.
For example, the DTD statement below ensures that the \elem{pre} element
preserves space, regardless of the default processing mode.

\begin{code}
<!ATTLIST pre xml:space nmtoken #fixed preserve>
\end{code}
\end{itemlist}

\subsubsection{XML Namespaces}			\label{sec:xmlns}

Using the \jargon{dialect} \const{xmlns}, the parser will interpret XML
namespaces.  In this case, the names of elements are returned as a term
of the format

\begin{quote}
    \arg{URL}\const{:}\arg{LocalName}
\end{quote}

If an identifier has no namespace and there is no default namespace it
is returned as a simple atom.  If an identifier has a namespace but this
namespace is undeclared, the namespace name rather than the related URL
is returned.

Attributes declaring namespaces (\exam{xmlns:\arg{ns}=\arg{url}} are
reported as if \const{xmlns} is not a defined resource.

In many cases, getting attribute-names as \exam{\arg{url}:\arg{name}} is
not desirable. Such terms are hard to unified and sometimes multiple
URLs may be mapped to the same identifier. This may happen due to poor
version management, poor standardisation or because the the application
doesn't care too much about versions. This package defines two
call-backs that can be set using set_sgml_parser/2 to deal with this
problem.

the call-back \term{xmlns}{} is called as XML namespaces are pushed on
the environment.  It can be used to extend a canonical mapping for later
use by the \term{urlns}{} call-back.  The following illustrates this
behaviour.  Any namespace containing \const{rdf-syntax} in its URL or
that is used as \const{rdf} namespace is canonised to \const{rdf}.  This
implies that any attribute and element name from the RDF namespace
appears as \exam{rdf:\arg{name}}.

\begin{code}
:- dynamic
	xmlns/3.

on_xmlns(rdf, URL, _Parser) :- !,
	asserta(xmlns(URL, rdf, _)).
on_xmlns(_, URL, _Parser) :-
	sub_atom(URL, _, _, _, rdf-syntax), !,
	asserta(xmlns(URL, rdf, _)).

load_rdf_xml(File, Term) :-
	load_structure(File, Term,
		       [ dialect(xmlns),
			 call(xmlns, on_xmlns),
			 call(urlns, xmlns)
		       ]).
\end{code}


\subsection{DTD-Handling}

The DTD ({\bf D}ocument {\bf T}ype {\bf D}efinition) is a separate
entity in sgml2pl, that can be created, freed, defined and inspected.
Like the parser itself, it is filled by opening it it as a Prolog output
stream and sending data to it. This section summarises the predicates
for handling the DTD.

\begin{description}
    \predicate{new_dtd}{2}{+DocType, -DTD}
Creates an empty DTD for the named \arg{DocType}. The returned
DTD-reference is an opaque term that can be used in the other predicates
of this package.

    \predicate{free_dtd}{1}{+DTD}
Deallocate all resources associated to the DTD. Further use of \arg{DTD}
is invalid.

    \predicate{load_dtd}{1}{+DTD, +File}
Define the DTD by loading the SGML-DTD file \arg{File}.  This predicate
is defined using the low-level open_dtd/3 predicate:

\begin{code}
load_dtd(DTD, DtdFile) :-
	open_dtd(DTD, [], DtdOut),
	open(DtdFile, read, DtdIn),
	copy_stream_data(DtdIn, DtdOut),
	close(DtdIn),
	close(DtdOut).
\end{code}

    \predicate{open_dtd}{3}{+DTD, +Options, -OutStream}
Open either a DTD as an output stream.  The option-list is currently empty.
See load_dtd/2 for an example.

    \predicate{dtd}{2}{+DocType, -DTD}
Find the DTD representing the indicated \jargon{doctype}. This predicate
uses a cache of DTD objects. If a doctype has no associated dtd, it
searches for a file using the file search path \const{dtd} using the
call:

\begin{code}
...,
absolute_file_name(dtd(Type),
		   [ extensions([dtd]),
		     access(read)
		   ], DtdFile),
...
\end{code}

    \predicate{dtd_property}{2}{+DTD, ?Property}
This predicate is used to examine the content of a DTD.  Property is
one of:

\begin{description}
    \termitem{doctype}{DocType}
An atom representing the document-type defined by this DTD.
    \termitem{elements}{ListOfElements}
A list of atoms representing the names of the elements in this DTD.
    \termitem{element}{Name, Omit, Content}
The DTD contains an element with the given name.  \arg{Omit} is a
term of the format \term{omit}{OmitOpen, OmitClose}, where both
arguments are booleans (\const{true} or \const{false} representing
whether the open- or close-tag may be omitted.  \arg{Content} is
the content-model of the element represented as a Prolog term.  This
term takes the following form:

    \begin{description}
	\termitem{empty}{}
    The element has no content.
	\termitem{cdata}{}
    The element contains non-parsed character data
	\termitem{'\#pcdata'}{}
    The element contains parsed character data
	\termitem{\arg{element}}{}
    An element with this name.
	\termitem{*}{SubModel}
    0 or more appearances.
	\termitem{?}{SubModel}
    0 or one appearance.
	\termitem{+}{SubModel}
    1 or more appearances.
	\termitem{,}{SubModel1, SubModel2}
    \arg{SubModel1} followed by \arg{SubModel2}.
	\termitem{\&}{SubModel1, SubModel2}
    \arg{SubModel1} and \arg{SubModel2} in any order.
	\termitem{{\tt\string|}}{SubModel1, SubModel2}
    \arg{SubModel1} or \arg{SubModel2}.
    \end{description}
    \termitem{attributes}{Element, ListOfAttributes}
\arg{ListOfAttributes} is a list of atoms representing the attributes of
the element \arg{Element}.
    \termitem{attribute}{Element, Attribute, Type, Default}
Query an element.  \arg{Type} is one of \const{cdata}, \const{entity},
\const{id}, \const{idref}, \const{name}, \const{nmtoken},
\const{notation}, \const{number} or \const{nutoken}.  For DTD types that
allow for a list, the notation \term{list}{Type} is used.  Finally, the
DTD construct \verb$(a|b|...)$ is mapped to the term
\term{nameof}{ListOfValues}.
    \termitem{entities}{ListOfEntities}
\arg{ListOfEntities} is a list of atoms representing the names of the
defined entities.
    \termitem{entity}{Name, Value}
\arg{Name} is the name of an entity with given value.  Value is one of
    \begin{description}
	\termitem{\arg{Atom}}{}
    If the value is atomic, it represents the literal value of the
    entity.
	\termitem{system}{Url}
    \arg{Url} is the URL of the system external entity.
	\termitem{public}{Id, Url}
    For external public entities, \arg{Id} is the identifier.  If an
    URL is provided this is returned in \arg{Url}. Otherwise this
    argument is unbound.
    \end{description}
    \termitem{notations}{ListOfNotations}
Returns a list holding the names of all \const{NOTATION} declarations.
    \termitem{notation}{Name, File}
Yields the declared file for from a \const{NOTATION} declaration. 
\end{description}
\end{description}


\subsection{Extracting a DTD}		\label{sec:implicitdtd}

Some documents have no DTD.  One of the neat facilities of this library
is that it builds a DTD while parsing a document with an
\jargon{implicit} DTD.  The resulting DTD contains all elements
encountered in the document.  For each element the content model is a
disjunction of elements and possibly \verb$#PCDATA$ that can be
repeated.  Thus, if in element \elem{x} whe found element \elem{y}
and CDATA, the model is:

\begin{code}
<!ELEMENT x - - (y|#PCDATA)*>
\end{code}

Any encountered attribute is added to the attribute list with the
type \const{CDATA} and default \const{\#IMPLIED}.

The example below extracts the elements used in an unknown XML document.

\begin{code}
elements_in_xml_document(File, Elements) :-
	load_structure(File, _,
		       [ dialect(xml),
			 dtd(DTD)
		       ]),
	dtd_property(DTD, elements(Elements)),
	free_dtd(DTD).
\end{code}


\subsection{Parsing Primitives}

\begin{description}
    \predicate{new_sgml_parser}{2}{-Parser, +Options}
Creates a new parser.  A parser can be used one or multiple times for
parsing documents or parts thereof.  It may be bound to a DTD or the
DTD may be left implicit, in which case it is created from the
document prologue or parsing is performed without a DTD.  Options:

\begin{description}
    \termitem{dtd}{?DTD}
If specified with an initialised DTD, this DTD is used for parsing the
document, regardless of the document prologue.  If specified using as
a variable, a reference to the created DTD is returned.  This DTD may
be created from the document prologue or build implicitely from the
document's content.
\end{description}

    \predicate{free_sgml_parser}{2}{+Parser}
Destroy all resources related to the parser.  This does not destroy
the DTD if the parser was created using the \term{dtd}{DTD} option.

    \predicate{set_sgml_parser}{2}{+Parser, +Option}
Sets attributes to the parser.  Currently defined attributes:
\begin{description}
    \termitem{file}{File}
Sets the file for reporting errors and warnings.  Sets the line
to 1.
    \termitem{line}{Line}
Sets the current line.  Useful if the stream is not at the start of
the (file) object for generating proper line-numbers.
    \termitem{dialect}{Dialect}
Set the markup dialect.  Known dialects:
    \begin{description}
	\termitem{sgml}{}
    The default dialect is to process as SGML.  This implies markup
    is case-insensitive and standard SGML abbreviation is allowed
    (abreviated attributes and omitted tags).
        \termitem{xml}{}
    This dialect is selected automatically if the processing instruction
    \verb$<?xml ...>$ is encountered.  See \secref{xml} for details.
	\termitem{xmlns}{}
    Process file as XML file with namespace support.  See \secref{xmlns}
    for details.
    \end{description}
\end{description}
    \predicate{get_sgml_parser}{2}{+Parser, -Option}
Retrieve infomation on the current status of the parser.  Notably useful
if the parser is used in the call-back mode.  Currently defined options:
\begin{description}
    \termitem{file}{-File}
Current file-name.  Note that this may be different from the provided
file if an external entity is being loaded.
    \termitem{charpos}{-CharPos}
Offset from where the parser started its processing in the file-object.
See \secref{indexaccess}.
    \termitem{source}{-Stream}
Prolog stream being processed.  May be used in the \const{on_begin},
etc.\ callbacks from sgml_parse/2.
    \termitem{dialect}{-Dialect}
Return the current dialect used by the parser (\const{sgml}, \const{xml}
or \const{xmlns}).
\end{description}

    \predicate{sgml_parse}{2}{+Parser, +Options}
Parse an \anyml{} file.  The parser can operate in two input and two
output modes.  Output is either a structured term as described with
load_structure/2 or call-backs on predefined events.  The first is
especially suitable for manipulating not-too-large documents, while
the latter provides a primitive means for handling very large
documents.

Input is either a stream or an goal that pushes characters into the
parser.	 A full description of the option-list is below.

\begin{description}
    \termitem{document}{+Term}
A variable that will be unified with a list describing the content of
the document (see load_structure/2).
    \termitem{source}{+Stream}
An input stream that is read. Either this option or the
\term{goal}{Goal} option must be provided.
    \termitem{goal}{+Goal}
\arg{Goal} is a callable term.  The predicate sgml_parse/2 opens an
output stream to the parser and invokes \term{call}{Goal, Stream},
where \arg{Goal} should write the data to be parsed to \arg{Stream}.
This option is not compatible to \term{parse}{element}.  This option
can be used for example to parse a Prolog atom:

\begin{code}
parse_atom(Atom, Term) :-
	new_sgml_parser(Parser, []),
	sgml_parse(Parser,
		   [ document(Term),
		     goal(provide_atom(Atom))
		   ]),
	free_sgml_parser(Parser).

provide_atom(Atom, ParserStream) :-
	write(ParserStream, Atom).
\end{code}

For example:

\begin{code}
?- parse_atom('<h1>hello world</h1>', X).

X = [element(h1, [], ['hello world'])] 
\end{code}
    \termitem{parse}{Unit}
If \const{file} (default), parse everything upto the end of the input.
If \const{element}, the parser will stop after reading the first
element.  Using \term{source}{Stream}, this implies reading is stopped
as soon as the element is complete, and another call may be issued on
the same stream to read the next element.  Using \term{goal}{Goal} as
input, the stream reports an I/O error after completing the first
element.  This exception destroyes the built \term{dcoument}{Term},
making this option useless using `Goal' driven input.
The value \const{content} may be used in a call-back from
\term{call}{\const{on_begin}, Pred} to parse individual elements after
validating their headers.
    \termitem{max_errors}{+MaxErrors}
Set the maximum number of errors.  If this number is exceeded further
writes to the stream will yield an I/O error exception.  Printing of
errors is suppressed after reaching this value.  The default is 100.
    \termitem{call}{+Event, :PredicateName}
Issue call-backs on the specified events.  \arg{PredicateName} is the
name of the predicate to call on this event, possibly prefixed with a
module identifier.  The defined events are:

\begin{description}
    \termitem{begin}{}
An open-tag has been parsed.  The named handler is called with three
arguments: \term{\arg{Handler}}{+Tag, +Attributes, +Parser}.
    \termitem{end}{}
A close-tag has been parsed.  The named handler is called with two
arguments: \term{\arg{Handler}}{+Tag, +Parser}.
    \termitem{cdata}{}
CDATA has been parsed.  The named handler is called with two
arguments: \term{\arg{Handler}}{+CDATA, +Parser}, where CDATA is
an atom representing the data.
    \termitem{entity}{}
An entity that cannot be represented as CDATA has been parsed. The named
handler is called with two arguments:
\term{\arg{Handler}}{+NameOrCode, +Parser}.
    \termitem{pi}{}
A processing instruction has been parsed. The named handler is called
with two arguments: \term{\arg{Handler}}{+Text, +Parser}, where
\arg{Text} is the text of the processing instruction.
    \termitem{xmlns}{}
When parsing an in \const{xmlns} mode, a new namespace declaraction is
pushed on the environment.  The named handler is called with three
arguments: \term{\arg{Handler}}{+NameSpace, +URL, +Parser}.  See
\secref{xmlns} for details.
    \termitem{urlns}{}
When parsing an in \const{xmlns} mode, this predicate can be used to
map a url into either a canonical URL for this namespace or another
internal identifier.  See \secref{xmlns} for details.
\end{description}
\end{description}
\end{description}


\subsubsection{Partial Parsing}

In some cases, part of a document needs to be parsed. One option is to
use load_structure/2 or one of its variations and extract the desired
elements from the returned structure. This is a clean solution,
especially on small and medium-sized documents. It however is unsuitable
for parsing really big documents.  Such documents can only be handled
with the call-back output interface realised by the
\term{call}{Event, Action} option of sgml_parse/2.  Event-driven
processing is not very natural in Prolog.

The SGML2PL library allows for a mixed approach.  Consider the case
where we want to process all descriptions from RDF elements in a
document.  The code below calls process_rdf_description/1 on any
element that is directly inside an RDF element.

\begin{code}
:- dynamic
	in_rdf/0.

load_rdf(File) :-
	retractall(in_rdf),
	open(File, read, In),
	new_sgml_parser(Parser, []),
	set_sgml_parser(Parser, file(File)),
	set_sgml_parser(Parser, dialect(xml)),
	sgml_parse(Parser,
		   [ source(In),
		     call(begin, on_begin),
		     call(end, on_end)
		   ]),
	close(In).

on_end('RDF', _) :-
	retractall(in_rdf).

on_begin('RDF', _, _) :-
	assert(in_rdf).
on_begin(Tag, Attr, Parser) :-
	in_rdf, !,
	sgml_parse(Parser,
		   [ document(Content),
		     parse(content)
		   ]),
	process_rdf_description(element(Tag, Attr, Content)).
\end{code}


\section{Processing Indexed Files}	\label{sec:indexaccess}

In some cases applications which to process small portions of large
SGML, XML or RDF files.  For example, the {\em OpenDirectory} project
by Netscape has produced a 90MB RDF file representing the main index.
The parser described here can process this document as a unit, but
loading takes 85 seconds on a Pentium-II 450 and the resulting term
requires about 70MB global stack.  One option is to process
the entire document and output it as a Prolog fact-based of RDF
tripplets, but in many cases this is undesirable.  Another example
is a large SGML file containing online documentation.  The application
normally wishes to provide only small portions at a time to the user.
Loading the entire document into memory is then undesirable.

Using the \term{parse}{element} option, we open a file, seek (using
seek/4) to the position of the element and read the desired element.

The index can be built using the call-back interface of
sgml_parse/2.  For example, the following code makes an index of
the \file{structure.rdf} file of the OpenDirectory projects:


\begin{code}
:- dynamic
	location/3.			% Id, File, Offset

rdf_index(File) :-
	retractall(location(_,_)),
	open(File, read, In, [type(binary)]),
	new_sgml_parser(Parser, []),
	set_sgml_parser(Parser, file(File)),
	set_sgml_parser(Parser, dialect(xml)),
	sgml_parse(Parser,
		   [ source(In),
		     call(begin, index_on_begin)
		   ]),
	close(In).

index_on_begin(_Element, Attributes, Parser) :-
	memberchk('r:id'=Id, Attributes),
	get_sgml_parser(Parser, charpos(Offset)),
	get_sgml_parser(Parser, file(File)),
	assert(location(Id, File, Offset)).
\end{code}


The following code extracts the RDF element with required id:

\begin{code}
rdf_element(Id, Term) :-
	location(Id, File, Offset),
	load_structure(File, Term,
		       [ dialect(xml),
			 offset(Offset),
			 parse(element)
		       ]).
\end{code}


\section{External entities}

While processing an SGML document the document may refer to external
data.  This occurs in three places: external parameter entities, 
normal external entities and the \const{DOCTYPE} declaration. The
current version of these tools deal rather primitively with external
data.  External entities can only be loaded from a file and the mapping
between the entity names and the file is done using a \jargon{catalog}
file in a format compatible to that used by James Clark's SP Parser.

Catalog files can be specified using two primitives: the predicate
sgml_register_catalog_file/2 or the environment variable
\env{SGML_CATALOG_FILES} (compatible to the SP package).

\begin{description}
    \predicate{sgml_register_catalog_file}{2}{+File, +Location}
Register the indicated \arg{File} as a catalog file.  \arg{Location}
is either \const{start} or \const{end} and defines whether the catalog
is considered first or last.  This predicate has no effect if \arg{File}
is already part of the catalog.

If no files are registered using this predicate, the first query on the
catalog examines \env{SGML_CATALOG_FILES} and fills the catalog with all
files in this path.
\end{description}

Two types of lines are used by this package. 

\begin{quote}
\const{DOCTYPE} \arg{doctype} \arg{file}\\
\const{PUBLIC}  \const{"}\arg{Id}\const{"} \arg{file}
\end{quote}

The specified \arg{file} path is taken relative to the location of
the catolog file. For the \const{DOCTYPE} declaraction, \const{sgml2pl}
first makes an attempt to resolve the \const{SYSTEM} or \const{PUBLIC}
identifier. If this fails it tries to resolve the \arg{doctype} using
the provided catalog files.

In the future we will design a call-back mechanism for locating and
processing external entities, so Prolog-based file-location and Prolog
resources can be used to store external entities.


\section{Missing functionality}

The current parser is rather limited.  Though suitable to deal with
many serious documents, it also fails a number of less-used features
in SGML and XML.  Known missing SGML features include

\begin{itemlist}
    \item [NOTATION on entities]
Though notation is fully parsed, notation attributes on external
entity declarations are not handed to the user.
    \item [SGML declaration]
The `SGML declaration' is fixed, though most of the parameters are
handled through indirections in the implementation.
\end{itemlist}

In XML mode the parser recognises SGML constructs that are not allowed
in XML.  Also various extensions of XML over SGML are not yet realised.


\section{Installation}

\subsection{Unix systems}

Installation on Unix system uses the commonly found {\em configure},
{\em make} and {\em make install} sequence. SWI-Prolog should be
installed before building this package. If SWI-Prolog is not installed
as \program{pl}, the environment variable \env{PL} must be set to the
name of the SWI-Prolog executable. Installation is now accomplished
using:

\begin{code}
% ./configure
% make
% make install
\end{code}

This installs the foreign libraries in \file{$PLBASE/lib/$PLARCH} and
the Prolog library files in \file{$PLBASE/library}, where
\file{$PLBASE} refers to the SWI-Prolog `home-directory'.


\subsection{Acknowledgements}

The Prolog representation for parsed documents is based on the
SWI-Prolog interface to SP by Anjo Anjewierden.

Richard O'Keefe pointed out a number of mistakes in a earlier version
of this parser.

\end{document}


