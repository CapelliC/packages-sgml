\documentclass[11pt]{article}
\usepackage{pl}
\usepackage{html}

\onefile
\htmloutput{html}				% Output directory
\htmlmainfile{index}				% Main document file
\bodycolor{white}				% Page colour

\renewcommand{\runningtitle}{SWI-Prolog SGML/XML parser}

\newcommand{\anyml}{$\cal X$ML}
\newcommand{\elem}[1]{{\tt\string<#1\string>}}

\begin{document}

\title{SWI-Prolog SGML/XML parser}
\author{Jan Wielemaker \\
	SWI, \\
	University of Amsterdam \\
	The Netherlands \\
	E-mail: \email{jan@swi.psy.uva.nl}}

\maketitle

\begin{abstract}
Markup languages are an increasingly important method for
data-representation and exchange.  This article documents the package
{\em sgml2pl}, a foreign library for SWI-Prolog to parse SGML
and XML documents, returning information on both the document and the
documents DTD.  The parser is designed to be small, fast and flexible.
\end{abstract}

\vfill

\tableofcontents

\vfill
\vfill

\newpage


\section{Introduction}

Markup languages have recently regained popularity for two reasons.  One
is document exchange, which is largely based on HTML, an instance of
SGML and the other is for data-exchange between programs, which is often
based on XML, which can be considered simplified and rationalised
version of SGML.

James Clark's SP parser is a flexible SGML and XML parser. Unfortunately
it has some drawbacks. It is very big, not very fast, cannot work under
event-driven input and is generally hard to program beyond the scope of
the very well documented generic interface. The generic interface
however does not provide access to the DTD, does not allow for flexible
handling of input or parsing the DTD independently of a document
instance.

The parser described in this document is small (less then 50 Kbytes
executable on a Pentium), fast (between 2 and 5 times faster then
SP), provides access to the DTD and flexible input handling.

The document output is equal to the output produced by \jargon{xml2pl},
an SP interface to SWI-Prolog written by Anjo Anjewierden.


\section{Bluffers Guide}

This package allows you to parse SGML, XML and HTML data into a Prolog
data structure. The high-level interface defined in \pllib{sgml}
provides access at the file-level, while the low-level interface defined
in the foreign module works with Prolog streams.  Please use the source
of \file{sgml.pl} as a starting point for dealing with data from other
sources then files, such as SWI-Prolog resources, network-sockets,
character strings, etc.  In the first example below loads an HTML file.

\begin{code}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
<title>Demo</title>
</head>
<body>

<h1 align=center>This is a demo</h1>

<p>Paragraphs in HTML need not be closed.

<p>This is called `omitted-tag' handling.
</body>
</html>
\end{code}

\begin{code}
?- load_html_file('test.html', Term),
   pretty_print(Term).

[ element(html,
          [],
          [ element(head,
                    [],
                    [ element(title,
                              [],
                              [ 'Demo'
                              ])
                    ]),
            element(body,
                    [],
                    [ '\n\n',
                      element(h1,
                              [ align = center
			      ],
                              [ 'This is a demo'
                              ]),
                      '\n\n',
                      element(p,
                              [],
                              [ 'Paragraphs in HTML need not be closed.\n\n'
                              ]),
                      element(p,
                              [],
                              [ 'This is called `omitted-tag\' handling.\n'
                              ])
                    ])
          ])
].
\end{code}

As you see, the document is a list, each element being an atom to
represent \const{CDATA} or a term \term{element}{Name, Attributes,
Content}. Entities (e.g.\ \verb$&lt$) are returned as part of
\const{CDATA}, unless they cannot be represented. See load_sgml_file/2
for details.


\subsection{`Goodies' Predicates}

These predicates are for basic usage of the library, converting entire
and self-contained files in one of the three supported \anyml{} dialects
into a structured term.  They are all expressed in load_structure/3.

\begin{description}
    \predicate{load_sgml_file}{2}{+File, -ListOfContent}
Same as \term{load_structure}{File, ListOfContent, [dialect(sgml)]}.
    \predicate{load_xml_file}{2}{+File, -ListOfContent}
Same as \term{load_structure}{File, ListOfContent, [dialect(xml)]}.
    \predicate{load_html_file}{2}{+File, -Content}
Load \arg{File} and parse as HTML.  Implemented as:

\begin{code}
load_html_file(File, Term) :-
	dtd(html, DTD),
	load_sgml_file(File, Term, DTD).
\end{code}
\end{description}


\section{Predicate Reference}

\subsection{Loading Structured Documents}

SGML or XML files are loaded through the common predicate
load_structure/3. This is a predicate with many options. For simplicity
a number of commonly used shorthands are provided: load_sgml_file/2,
load_xml_file/2, and load_html_file/2.

\begin{description}
    \predicate{load_structure}{3}{+File, --ListOfContent, +Options}
Load the \anyml{} file \arg{File} and return the resulting structure
in \arg{ListOfContent}. \arg{Options} is a list of options controlling the
conversion process.

A proper \anyml{} document contains only a single toplevel element whose
name matches the document type.  Nevertheless, a list is returned for
consistency with the representation of element content. The
\arg{ListOfContent} consists of three types:

\begin{description}
    \termitem{\arg{Atom}}{}
Atoms are used to represent \const{CDATA}.  Note this is possible
in SWI-Prolog, as there is no length-limit on atoms and atom garbage
collection is provided.

    \termitem{element}{Name, ListAttributes, ListOfContent}
\arg{Name} is the name of the element. Using SGML, which is
case-insensitive, all element names are returned as lowercase atoms.

\arg{ListOfAttributes} is a list of \arg{Name}=\arg{Value} pairs for
attributes that appeared in the source. No information is returned on
other attributes, such as \const{fixed} or \const{default} attributes.
See dtd_property/2 for accessing the DTD for this information.
Attributes of type \const{CDATA} are returned literal. Attributes of
type \const{NUMBER} are returned as a Prolog integer. All other
attribute values are returned as lowercase atoms.%
	\bug{List-valued attributes are returned as a single atom.}

\arg{ListOfContent} defines the content for the element.

    \termitem{entity}{Code}
If a character-entity (e.g. \verb$&#913;$) is encoutered that cannot
be represented in the Prolog character set, this term is returned,
representing the referred character code.

    \termitem{entity}{Name}
If an entity refers to a character-entity holding a single character,
but this character cannot be represented in the Prolog character set,
this term is returned. For example, the HTML input text
\verb$&Alpha; &lt &Beta;$ is returned as below.  Please note the
conversion to lowercase because SGML is case-insensitive.

\begin{code}
[ entity(alpha), ' < ', entity(beta) ]
\end{code}

This is a special case of \term{entity}{Code}, intended to handle
special symbols by their name rather then character code.
\end{description}

The \arg{Options} list controls the conversion process.  Currently
defined options are:

\begin{description}
    \termitem{dtd}{?DTD}
Reference to a DTT object.  If specified, the \verb$<!DOCTYPE ...>$
declaration is ignored and the document is parsed and validated against
the provided DTD.  If provided as a variable, the implicitly created
DTD is returned.  See \secref{implicitdtd}.

    \termitem{dialect}{+Dialect}
Specify the parsing dialect.  Supported are \const{sgml} (default)
and \arg{xml}. See \secref{xml} for details on the differences.

    \termitem{file}{+Name}
Sets the name of the file on which errors are reported. Sets the
linenumber to 1.

    \termitem{line}{+Line}
Sets the starting line-number for reporting errors.

    \termitem{max_errors}{+Max}
Sets the maximum number of errors.  If this number is reached, an
exception of the format below is raised.  The default is 50.

\begin{quote}
\term{error}{\term{limit_exceeded}{max_errors, Max}, _}
\end{quote}
\end{description}
\end{description}

\subsection{XML documents}			\label{sec:xml}

The parser can operate in two modes: \const{sgml} mode and \const{xml}
mode, as defined by the \term{dialect}{Dialect} option. Regardless of
this option, if the first line of the document reads as below, the
parser is switched automatically into XML mode.

\begin{code}
<?xml ... ?>
\end{code}

Currently switching to XML mode implies:

\begin{itemlist}
    \item [XML empty elements]
The construct \verb$<element [attribute...] />$ is recognised as an
empty element.
    \item [Predefined entities]
The following entitities are predefined:
\const{lt} (\verb$<$),
\const{gt} (\verb$>$),
\const{amp} (\verb$&$),
\const{apos} (\verb$'$) and
\const{quot} (\verb$"$).
    \item [Case sensitivity]
In XML mode, names are treated case-sensitive, except for the DTD
reserved names (i.e. \const{ELEMENT}, etc.).
    \item [Character classes]
In XML mode, underscores (\verb$_$) and colon (\verb$:$) are allowed in
names.
\end{itemlist}


\subsection{DTD-Handling}

The DTD ({\bf D}ocument {\bf T}ype {\bf D}efinition) is a separate
entity in sgml2pl, that can be created, freed, defined and inspected.
Like the parser itself, it is filled by opening it it as a Prolog output
stream and sending data to it. This section summarises the predicates
for handling the DTD.

\begin{description}
    \predicate{new_dtd}{2}{+DocType, -DTD}
Creates an empty DTD for the named \arg{DocType}. The returned
DTD-reference is an opaque term that can be used in the other predicates
of this package.

    \predicate{free_dtd}{1}{+DTD}
Deallocate all resources associated to the DTD. Further use of \arg{DTD}
is invalid.

    \predicate{load_dtd}{1}{+DTD, +File}
Define the DTD by loading the SGML-DTD file \arg{File}.  This predicate
is defined using the low-level sgml_open/2 predicate:

\begin{code}
load_dtd(DTD, DtdFile) :-
	sgml_open(DTD, [], DtdOut),
	open(DtdFile, read, DtdIn),
	copy_stream_data(DtdIn, DtdOut),
	close(DtdIn),
	close(DtdOut).
\end{code}

    \predicate{dtd}{2}{+DocType, -DTD}
Find the DTD representing the indicated \jargon{doctype}. This predicate
uses a cache of DTD objects. If a doctype has no associated dtd, it
searches for a file using the file search path \const{dtd} using the
call:

\begin{code}
...,
absolute_file_name(dtd(Type),
		   [ extensions([dtd]),
		     access(read)
		   ], DtdFile),
...
\end{code}

    \predicate{dtd_property}{2}{+DTD, ?Property}
This predicate is used to examine the content of a DTD.  Property is
one of:

\begin{description}
    \termitem{doctype}{DocType}
An atom representing the document-type defined by this DTD.
    \termitem{elements}{ListOfElements}
A list of atoms representing the names of the elements in this DTD.
    \termitem{element}{Name, Omit, Content}
The DTD contains an element with the given name.  \arg{Omit} is a
term of the format \term{omit}{OmitOpen, OmitClose}, where both
arguments are booleans (\const{true} or \const{false} representing
whether the open- or close-tag may be omitted.  \arg{Content} is
the content-model of the element represented as a Prolog term.  This
term takes the following form:

    \begin{description}
	\termitem{empty}{}
    The element has no content.
	\termitem{cdata}{}
    The element contains non-parsed character data
	\termitem{'\#pcdata'}{}
    The element contains parsed character data
	\termitem{\arg{element}}{}
    An element with this name.
	\termitem{*}{SubModel}
    0 or more appearances.
	\termitem{?}{SubModel}
    0 or one appearance.
	\termitem{+}{SubModel}
    1 or more appearances.
	\termitem{,}{SubModel1, SubModel2}
    \arg{SubModel1} followed by \arg{SubModel2}.
	\termitem{\&}{SubModel1, SubModel2}
    \arg{SubModel1} and \arg{SubModel2} in any order.
	\termitem{{\tt\string|}}{SubModel1, SubModel2}
    \arg{SubModel1} or \arg{SubModel2}.
    \end{description}
    \termitem{attributes}{Element, ListOfAttributes}
\arg{ListOfAttributes} is a list of atoms representing the attributes of
the element \arg{Element}.
    \termitem{attribute}{Element, Attribute, Type, Default}
Query an element.  \arg{Type} is one of \const{cdata}, \const{entity},
\const{id}, \const{idref}, \const{name}, \const{nmtoken},
\const{notation}, \const{number} or \const{nutoken}.  For DTD types that
allow for a list, the notation \term{list}{Type} is used.  Finally, the
DTD construct \verb$(a|b|...)$ is mapped to the term
\term{nameof}{ListOfValues}.
    \termitem{entities}{ListOfEntities}
\arg{ListOfEntities} is a list of atoms representing the names of the
defined entities.
    \termitem{entity}{Name, Value}
\arg{Name} is the name of an entity with given value.  Value is one of
    \begin{description}
	\termitem{\arg{Atom}}{}
    If the value is atomic, it represents the literal value of the
    entity.
	\termitem{system}{Url}
    \arg{Url} is the URL of the system external entity.
	\termitem{public}{Id, Url}
    For external public entities, \arg{Id} is the identifier.  If an
    URL is provided this is returned in \arg{Url}. Otherwise this
    argument is unbound.
    \end{description}
\end{description}
\end{description}


\subsection{Extracting a DTD}		\label{sec:implicitdtd}

Some documents have no DTD.  One of the neat facilities of this library
is that is builds a DTD while parsing a document with an
\jargon{implicit} DTD.  The resulting DTD contains all elements
encountered in the document.  For each element the content model is a
disjunction of elements and possibly \verb$#PCDATA$ that can be
repeated.  Thus, if in element \elem{x} whe found element \elem{y}
and CDATA, the model is:

\begin{code}
<!ELEMENT x - - (y|#PCDATA)*>
\end{code}

Any encountered attribute is added to the attribute list with the
type \const{CDATA} and default \const{\#IMPLIED}.

The example below extracts the elements used in an unknown XML document.

\begin{code}
elements_in_xml_document(File, Elements) :-
	load_structure(File, _,
		       [ dialect(xml),
			 dtd(DTD)
		       ]),
	dtd_property(DTD, elements(Elements)),
	free_dtd(DTD).
\end{code}


\subsection{Primitives}

\begin{description}
    \predicate{sgml_open}{2}{+DTDOrParser, +Options, -OutStream}
Open either a DTD or an SGML parser as an output stream.  For a DTD,
the option-list is currently empty.

Opening a parser is a bit unconventional as we aim at returning a Prolog
structure representing the document (see load_sgml_file/[2,3]), but we
cannot pass the term-reference of the requested document as
term-references do not survive over foreign language calls. Hence,
copying the data to be parsed should happen in the \term{goal}{Goal}
argument. We provide the implementation of load_sgml_file/2 for
reference:

\begin{code}
load_sgml_file(File, Term) :-
	open(File, read, SgmlIn),
	new_sgml_parser(Parser, [dtd(DTD)]),
	sgml_open(Parser,
		  [ document(Term),
		    goal(copy_stream_data(SgmlIn, SgmlOut))
		  ],
		  SgmlOut),
	close(SgmlIn),
	close(SgmlOut),
	free_dtd(DTD).
\end{code}

\begin{description}
    \termitem{document}{+Term}
A variable that will be unified with a list describing the content of
the document (see load_sgml_file/2).
    \termitem{goal}{+Goal}
\arg{Goal} is a callable term that should copy the input to the parser.
The provided output stream is flushed automatically on completion of
\arg{Goal}.
    \termitem{max_errors}{+MaxErrors}
Set the maximum number of errors.  If this number is exceeded further
writes to the stream will yield an I/O error exception.  Printing of
errors is suppressed after reaching this value.  The default is 100.
\end{description}
\end{description}


\section{Installation}

\subsection{Unix systems}

Installation on Unix system uses the commonly found {\em configure},
{\em make} and {\em make install} sequence. SWI-Prolog should be
installed before building this package. If SWI-Prolog is not installed
as \program{pl}, the environment variable \env{PL} must be set to the
name of the SWI-Prolog executable. Installation is now accomplished
using:

\begin{code}
% ./configure
% make
% make install
\end{code}

This installs the foreign libraries in \file{$PLBASE/lib/$PLARCH} and
the Prolog library files in \file{$PLBASE/library}, where
\file{$PLBASE} refers to the SWI-Prolog `home-directory'.

\end{document}

